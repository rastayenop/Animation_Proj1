#version 430 core

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;

#define M_PI                3.14159265358979323846
#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.001

float k_a = 0.1;
float k_d = 0.5;
vec4 C_a = vec4(0.0,0.0,0.0,1.0);
vec4 C_d = vec4(0.0,0.0,0.0,1.0);
vec4 C_s = vec4(0.0,0.0,0.0,1.0);

struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};


struct indirect_hit_t {
    vec4 origin;
    vec4 dir;
    vec4 hit_point;
    vec4 normal;
    vec4 color;
};


bool intersectBoundingBox(vec4 origin, vec4 dir) {
    vec3 l1 = (bbmin - origin.xyz)/dir.xyz;
    vec3 l2 = (bbmax - origin.xyz)/dir.xyz;

    float c_min = max(max(min(l1.x, l2.x), min(l1.y, l2.y)), min(l1.z, l2.z));
    float c_max = min(min(max(l1.x, l2.x), max(l1.y, l2.y)), max(l1.z, l2.z));
    if (c_max < 0) {
        return false;
    } else if (c_min > c_max) {
        return false;
    }
    return true;
}

vec4 interpolateNormal(hitinfo_t h){
  vec4 normal0 = normals[indices[h.hit_vptr]];
  vec4 normal1 = normals[indices[h.hit_vptr+1]];
  vec4 normal2 = normals[indices[h.hit_vptr+2]];
  vec4 normale = h.t.w*normal0 + h.t.y*normal1 + h.t.z*normal2;
  return normalize(normale);
}

vec4 interpolateColor(hitinfo_t h)
{
	// TODO
  vec4 color0 = colors[indices[h.hit_vptr]];
  vec4 color1 = colors[indices[h.hit_vptr+1]];
  vec4 color2 = colors[indices[h.hit_vptr+2]];
  vec4 color = h.t.w*color0 + h.t.y*color1 + h.t.z*color2;
  return color;
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{
  vec4 e1 = vertices[indices[ptr+1]] - vertices[indices[ptr]];
  vec4 e2 = vertices[indices[ptr+2]] - vertices[indices[ptr]];
  vec4 t  = origin - vertices[indices[ptr]];
  vec3 p = cross(dir.xyz, e2.xyz);
  vec3 q = cross(t.xyz, e1.xyz);
  dist.xyz = (1/dot(p, e1.xyz)) * vec3(dot(q, e2.xyz), dot(p, t.xyz), dot(q, dir.xyz));
  dist.w = 1 - dist.y - dist.z ;
  if ((dist.y + dist.z)<1 && dist.y>0 && dist.z>0 && dist.x>EPS && dist.y<1 && dist.z<1 ) {
    return true;
  }
  return false;
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
  vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
  //check si on tape l'objet
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(intersectTriangle(origin, dir, j, dist)) {
        if (dist.x < h.t.x) {
          h.hit_vptr = j;
          h.t = dist;
          hit = true;
        }
			}
		}
	}
  //check si on tape le sol
  float lambda = dot(vec3(0,-groundDistance,0)-origin.xyz, vec3(0,1,0))/ dot(dir.xyz, vec3(0,1,0));
  if (dir.y<0 && h.t.x>lambda && lambda>EPS && lambda<1000){ //si on tape le sol est ce que le sol est devant l'objet ?
    h.hit_vptr = -1;
    h.t.x = lambda;
    h.t.yzw = origin.xyz + lambda * dir.xyz;
    hit = true;
  }
	return hit;
}


bool isShady (vec4 point) {
  vec4 pointtolight;
  vec4 dist;
  pointtolight.xyz = normalize(lightPosition - point.xyz);
  pointtolight.w = 0;
  for(int j = 0; j < indices.length(); j += 3) {
    if(intersectTriangle(point, pointtolight, j, dist)) {
      return true;
    }
  }
  return false;
}

float fTheta (vec4 H, vec4 lightVector) {
  float cos_theta = dot(H, lightVector);
  float c_i_theta = pow(pow(eta, 2) - (1 - cos_theta * cos_theta), 0.5);
  float f_s = ((cos_theta - c_i_theta) / (cos_theta + c_i_theta)) * ((cos_theta - c_i_theta) / (cos_theta + c_i_theta));
  float f_p = (pow(eta,2)*cos_theta - c_i_theta) / (pow(eta,2)*cos_theta + c_i_theta) * (pow(eta,2)*cos_theta - c_i_theta) / (pow(eta,2)*cos_theta + c_i_theta);
  float f_theta_d;
  return (f_s + f_p)*0.5;
}

vec4 getPointOnGround(vec4 dir, vec4 start) {
  float cosTheta = dot(dir, vec4(0,-1,0,0));
  float lambda = groundDistance/cosTheta;
  return start + (lambda * dir);
}

vec4 get_color(vec4 start, vec4 dir, hitinfo_t h){
  vec4 vertColor;
  vec4 normale;
  if (h.hit_vptr==-1){
    vertColor = vec4(0,0,1,1);
    normale = vec4(0,1,0,0);
  }
  else {
    vertColor = interpolateColor(h);
    normale = interpolateNormal(h);
  }
  vec4 lightVector = vec4(0.0);
  vec4 visiblePoint = start + h.t.x * dir;
  vec4 color;
  vec4 H;
  C_a = k_a * lightIntensity * vertColor;
  if(isShady(visiblePoint)) {
    color = C_a;
  }
  else {
    lightVector.xyz = normalize(lightPosition - visiblePoint.xyz);
    C_d = k_d * max(dot(normale, lightVector), 0) * lightIntensity * vertColor;
    H = normalize(-dir + lightVector);
    C_s = fTheta(H, lightVector) * vertColor * pow(max(dot(normale, H), 0), shininess) * lightIntensity;
    color = C_a + C_d + C_s;
  }
  return color;
}

const int MAX_TRACE = 1;


vec4 trace(vec4 origin, vec4 dir)
{
	// TODO: trace a ray in the scene, see what it intersects, bounce around
  vec4 dist;
  hitinfo_t h;

  if (isIntersected(origin, dir, h)){
    return get_color(origin, dir, h);

  }
  return vec4(1.0);
}



layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5));
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates.
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);

    imageStore(framebuffer, pix, color);
}
