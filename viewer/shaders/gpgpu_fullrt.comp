#version 430 core

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;

#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.001

float k_a = 0.1;
float k_d = 0.5;
vec4 C_a = vec4(0.0,0.0,0.0,1.0);
vec4 C_d = vec4(0.0,0.0,0.0,1.0);
vec4 C_s = vec4(0.0,0.0,0.0,1.0);

struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};





bool intersectBoundingBox(vec4 origin, vec4 dir) {
    vec3 l1 = (bbmin - origin.xyz)/dir.xyz;
    vec3 l2 = (bbmax - origin.xyz)/dir.xyz;

    float c_min = max(max(min(l1.x, l2.x), min(l1.y, l2.y)), min(l1.z, l2.z));
    float c_max = min(min(max(l1.x, l2.x), max(l1.y, l2.y)), max(l1.z, l2.z));
    if (c_max < 0) {
        return false;
    } else if (c_min > c_max) {
        return false;
    }
    return true;
}

vec4 interpolateNormal(hitinfo_t h){
  vec4 normal0 = normals[indices[h.hit_vptr]];
  vec4 normal1 = normals[indices[h.hit_vptr+1]];
  vec4 normal2 = normals[indices[h.hit_vptr+2]];
  vec4 normale = h.t.w*normal0 + h.t.y*normal1 + h.t.z*normal2;
  return normalize(normale);
}

vec4 interpolateColor(hitinfo_t h)
{
	// TODO
  vec4 color0 = colors[indices[h.hit_vptr]];
  vec4 color1 = colors[indices[h.hit_vptr+1]];
  vec4 color2 = colors[indices[h.hit_vptr+2]];
  vec4 color = h.t.w*color0 + h.t.y*color1 + h.t.z*color2;
  return color;
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{
  vec4 e1 = vertices[indices[ptr+1]] - vertices[indices[ptr]];
  vec4 e2 = vertices[indices[ptr+2]] - vertices[indices[ptr]];
  vec4 t  = origin - vertices[indices[ptr]];
  vec3 p = cross(dir.xyz, e2.xyz);
  vec3 q = cross(t.xyz, e1.xyz);
  dist.xyz = (1/dot(p, e1.xyz)) * vec3(dot(q, e2.xyz), dot(p, t.xyz), dot(q, dir.xyz));
  dist.w = 1 - dist.y - dist.z ;
  if ((dist.y + dist.z)<1 && dist.y>0 && dist.z>0 && dist.x>EPS && dist.y<1 && dist.z<1 ) {
    return true;
  }
  return false;
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
  vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(intersectTriangle(origin, dir, j, dist)) {
        if (dist.x < h.t.x) {
          h.hit_vptr = j;
          h.t = dist;
          hit = true;
        }
			}
		}
	}
	return hit;
}

bool isShady (vec4 point, vec4 from, hitinfo_t h) {
  vec4 pointtolight;
  vec4 dist;
  pointtolight.xyz = normalize(lightPosition - point.xyz);
  pointtolight.w = 0;
  for(int j = 0; j < indices.length(); j += 3) {
    if(intersectTriangle(point, pointtolight, j, dist)) {
      return true;
    }
  }
  return false;
}

float fTheta (vec4 H, vec4 lightVector) {
  float cos_theta = dot(H, lightVector);
  float c_i_theta = pow(pow(eta, 2) - (1 - pow(cos_theta, 2)), 0.5);
  float f_s = pow((cos_theta - c_i_theta) / (cos_theta + c_i_theta), 2);
  float f_p = pow((pow(eta,2)*cos_theta - c_i_theta) / (pow(eta,2)*cos_theta + c_i_theta), 2);
  float f_theta_d;
  return (f_s + f_p)*0.5;
}



const int MAX_TRACE = 1;


vec4 trace(vec4 origin, vec4 dir)
{
	// TODO: trace a ray in the scene, see what it intersects, bounce around
    return vec4(1);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = pix / (size - vec2(0.5,0.5));
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates.
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);
    vec4 dist;
    hitinfo_t h;
    vec4 visiblePoint;
    vec4 lightVector = vec4(0.0);
    vec4 normale;
    vec4 H;

    if (intersectBoundingBox(eye, dir)) {
      if (isIntersected(eye, dir, h)){
        visiblePoint = eye + h.t.x * dir;
        C_a = k_a * lightIntensity * interpolateColor(h);
        if(isShady(visiblePoint, dir, h)) {
          color = C_a;
        }
        else {
          lightVector.xyz = normalize(lightPosition - visiblePoint.xyz);
          normale = interpolateNormal(h);
          C_d = k_d * max(dot(normale, lightVector), 0) * lightIntensity * interpolateColor(h);
          H = normalize(-dir + lightVector);
          C_s = fTheta(H, lightVector) * interpolateColor(h) * pow(max(dot(normale, H), 0), shininess) * lightIntensity;
          color = C_a + C_d + C_s;
        }
      }
    }
    else if (dir.z < 0) {
      color = vec4(0,0,0,1);
    }
    else {
      color = vec4(1,1,1,1);
    }


    imageStore(framebuffer, pix, color);
}
